{"ast":null,"code":"import _classCallCheck from \"/home/DigPatho/Streamlit-Image-Annotation/streamlit_image_annotation/Point/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/DigPatho/Streamlit-Image-Annotation/streamlit_image_annotation/Point/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/home/DigPatho/Streamlit-Image-Annotation/streamlit_image_annotation/Point/frontend/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/home/DigPatho/Streamlit-Image-Annotation/streamlit_image_annotation/Point/frontend/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/home/DigPatho/Streamlit-Image-Annotation/streamlit_image_annotation/Point/frontend/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/DigPatho/Streamlit-Image-Annotation/streamlit_image_annotation/Point/frontend/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Util } from '../Util.js';\nimport { Factory } from '../Factory.js';\nimport { Shape } from '../Shape.js';\nimport { Path } from './Path.js';\nimport { Text, stringToArray } from './Text.js';\nimport { getNumberValidator } from '../Validators.js';\nimport { _registerNode } from '../Global.js';\nvar EMPTY_STRING = '',\n  NORMAL = 'normal';\nfunction _fillFunc(context) {\n  context.fillText(this.partialText, 0, 0);\n}\nfunction _strokeFunc(context) {\n  context.strokeText(this.partialText, 0, 0);\n}\nexport var TextPath = /*#__PURE__*/function (_Shape) {\n  _inherits(TextPath, _Shape);\n  var _super = _createSuper(TextPath);\n  function TextPath(config) {\n    var _this;\n    _classCallCheck(this, TextPath);\n    _this = _super.call(this, config);\n    _this.dummyCanvas = Util.createCanvasElement();\n    _this.dataArray = [];\n    _this.dataArray = Path.parsePathData(_this.attrs.data);\n    _this.on('dataChange.konva', function () {\n      this.dataArray = Path.parsePathData(this.attrs.data);\n      this._setTextData();\n    });\n    _this.on('textChange.konva alignChange.konva letterSpacingChange.konva kerningFuncChange.konva fontSizeChange.konva fontFamilyChange.konva', _this._setTextData);\n    _this._setTextData();\n    return _this;\n  }\n  _createClass(TextPath, [{\n    key: \"_sceneFunc\",\n    value: function _sceneFunc(context) {\n      context.setAttr('font', this._getContextFont());\n      context.setAttr('textBaseline', this.textBaseline());\n      context.setAttr('textAlign', 'left');\n      context.save();\n      var textDecoration = this.textDecoration();\n      var fill = this.fill();\n      var fontSize = this.fontSize();\n      var glyphInfo = this.glyphInfo;\n      if (textDecoration === 'underline') {\n        context.beginPath();\n      }\n      for (var i = 0; i < glyphInfo.length; i++) {\n        context.save();\n        var p0 = glyphInfo[i].p0;\n        context.translate(p0.x, p0.y);\n        context.rotate(glyphInfo[i].rotation);\n        this.partialText = glyphInfo[i].text;\n        context.fillStrokeShape(this);\n        if (textDecoration === 'underline') {\n          if (i === 0) {\n            context.moveTo(0, fontSize / 2 + 1);\n          }\n          context.lineTo(fontSize, fontSize / 2 + 1);\n        }\n        context.restore();\n      }\n      if (textDecoration === 'underline') {\n        context.strokeStyle = fill;\n        context.lineWidth = fontSize / 20;\n        context.stroke();\n      }\n      context.restore();\n    }\n  }, {\n    key: \"_hitFunc\",\n    value: function _hitFunc(context) {\n      context.beginPath();\n      var glyphInfo = this.glyphInfo;\n      if (glyphInfo.length >= 1) {\n        var p0 = glyphInfo[0].p0;\n        context.moveTo(p0.x, p0.y);\n      }\n      for (var i = 0; i < glyphInfo.length; i++) {\n        var p1 = glyphInfo[i].p1;\n        context.lineTo(p1.x, p1.y);\n      }\n      context.setAttr('lineWidth', this.fontSize());\n      context.setAttr('strokeStyle', this.colorKey);\n      context.stroke();\n    }\n  }, {\n    key: \"getTextWidth\",\n    value: function getTextWidth() {\n      return this.textWidth;\n    }\n  }, {\n    key: \"getTextHeight\",\n    value: function getTextHeight() {\n      Util.warn('text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height.');\n      return this.textHeight;\n    }\n  }, {\n    key: \"setText\",\n    value: function setText(text) {\n      return Text.prototype.setText.call(this, text);\n    }\n  }, {\n    key: \"_getContextFont\",\n    value: function _getContextFont() {\n      return Text.prototype._getContextFont.call(this);\n    }\n  }, {\n    key: \"_getTextSize\",\n    value: function _getTextSize(text) {\n      var dummyCanvas = this.dummyCanvas;\n      var _context = dummyCanvas.getContext('2d');\n      _context.save();\n      _context.font = this._getContextFont();\n      var metrics = _context.measureText(text);\n      _context.restore();\n      return {\n        width: metrics.width,\n        height: parseInt(this.attrs.fontSize, 10)\n      };\n    }\n  }, {\n    key: \"_setTextData\",\n    value: function _setTextData() {\n      var that = this;\n      var size = this._getTextSize(this.attrs.text);\n      var letterSpacing = this.letterSpacing();\n      var align = this.align();\n      var kerningFunc = this.kerningFunc();\n      this.textWidth = size.width;\n      this.textHeight = size.height;\n      var textFullWidth = Math.max(this.textWidth + ((this.attrs.text || '').length - 1) * letterSpacing, 0);\n      this.glyphInfo = [];\n      var fullPathWidth = 0;\n      for (var l = 0; l < that.dataArray.length; l++) {\n        if (that.dataArray[l].pathLength > 0) {\n          fullPathWidth += that.dataArray[l].pathLength;\n        }\n      }\n      var offset = 0;\n      if (align === 'center') {\n        offset = Math.max(0, fullPathWidth / 2 - textFullWidth / 2);\n      }\n      if (align === 'right') {\n        offset = Math.max(0, fullPathWidth - textFullWidth);\n      }\n      var charArr = stringToArray(this.text());\n      var spacesNumber = this.text().split(' ').length - 1;\n      var p0, p1, pathCmd;\n      var pIndex = -1;\n      var currentT = 0;\n      var getNextPathSegment = function getNextPathSegment() {\n        currentT = 0;\n        var pathData = that.dataArray;\n        for (var j = pIndex + 1; j < pathData.length; j++) {\n          if (pathData[j].pathLength > 0) {\n            pIndex = j;\n            return pathData[j];\n          } else if (pathData[j].command === 'M') {\n            p0 = {\n              x: pathData[j].points[0],\n              y: pathData[j].points[1]\n            };\n          }\n        }\n        return {};\n      };\n      var findSegmentToFitCharacter = function findSegmentToFitCharacter(c) {\n        var glyphWidth = that._getTextSize(c).width + letterSpacing;\n        if (c === ' ' && align === 'justify') {\n          glyphWidth += (fullPathWidth - textFullWidth) / spacesNumber;\n        }\n        var currLen = 0;\n        var attempts = 0;\n        p1 = undefined;\n        while (Math.abs(glyphWidth - currLen) / glyphWidth > 0.01 && attempts < 20) {\n          attempts++;\n          var cumulativePathLength = currLen;\n          while (pathCmd === undefined) {\n            pathCmd = getNextPathSegment();\n            if (pathCmd && cumulativePathLength + pathCmd.pathLength < glyphWidth) {\n              cumulativePathLength += pathCmd.pathLength;\n              pathCmd = undefined;\n            }\n          }\n          if (Object.keys(pathCmd).length === 0 || p0 === undefined) {\n            return undefined;\n          }\n          var needNewSegment = false;\n          switch (pathCmd.command) {\n            case 'L':\n              if (Path.getLineLength(p0.x, p0.y, pathCmd.points[0], pathCmd.points[1]) > glyphWidth) {\n                p1 = Path.getPointOnLine(glyphWidth, p0.x, p0.y, pathCmd.points[0], pathCmd.points[1], p0.x, p0.y);\n              } else {\n                pathCmd = undefined;\n              }\n              break;\n            case 'A':\n              var start = pathCmd.points[4];\n              var dTheta = pathCmd.points[5];\n              var end = pathCmd.points[4] + dTheta;\n              if (currentT === 0) {\n                currentT = start + 0.00000001;\n              } else if (glyphWidth > currLen) {\n                currentT += Math.PI / 180.0 * dTheta / Math.abs(dTheta);\n              } else {\n                currentT -= Math.PI / 360.0 * dTheta / Math.abs(dTheta);\n              }\n              if (dTheta < 0 && currentT < end || dTheta >= 0 && currentT > end) {\n                currentT = end;\n                needNewSegment = true;\n              }\n              p1 = Path.getPointOnEllipticalArc(pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], currentT, pathCmd.points[6]);\n              break;\n            case 'C':\n              if (currentT === 0) {\n                if (glyphWidth > pathCmd.pathLength) {\n                  currentT = 0.00000001;\n                } else {\n                  currentT = glyphWidth / pathCmd.pathLength;\n                }\n              } else if (glyphWidth > currLen) {\n                currentT += (glyphWidth - currLen) / pathCmd.pathLength / 2;\n              } else {\n                currentT = Math.max(currentT - (currLen - glyphWidth) / pathCmd.pathLength / 2, 0);\n              }\n              if (currentT > 1.0) {\n                currentT = 1.0;\n                needNewSegment = true;\n              }\n              p1 = Path.getPointOnCubicBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], pathCmd.points[4], pathCmd.points[5]);\n              break;\n            case 'Q':\n              if (currentT === 0) {\n                currentT = glyphWidth / pathCmd.pathLength;\n              } else if (glyphWidth > currLen) {\n                currentT += (glyphWidth - currLen) / pathCmd.pathLength;\n              } else {\n                currentT -= (currLen - glyphWidth) / pathCmd.pathLength;\n              }\n              if (currentT > 1.0) {\n                currentT = 1.0;\n                needNewSegment = true;\n              }\n              p1 = Path.getPointOnQuadraticBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3]);\n              break;\n          }\n          if (p1 !== undefined) {\n            currLen = Path.getLineLength(p0.x, p0.y, p1.x, p1.y);\n          }\n          if (needNewSegment) {\n            needNewSegment = false;\n            pathCmd = undefined;\n          }\n        }\n      };\n      var testChar = 'C';\n      var glyphWidth = that._getTextSize(testChar).width + letterSpacing;\n      var lettersInOffset = offset / glyphWidth - 1;\n      for (var k = 0; k < lettersInOffset; k++) {\n        findSegmentToFitCharacter(testChar);\n        if (p0 === undefined || p1 === undefined) {\n          break;\n        }\n        p0 = p1;\n      }\n      for (var i = 0; i < charArr.length; i++) {\n        findSegmentToFitCharacter(charArr[i]);\n        if (p0 === undefined || p1 === undefined) {\n          break;\n        }\n        var width = Path.getLineLength(p0.x, p0.y, p1.x, p1.y);\n        var kern = 0;\n        if (kerningFunc) {\n          try {\n            kern = kerningFunc(charArr[i - 1], charArr[i]) * this.fontSize();\n          } catch (e) {\n            kern = 0;\n          }\n        }\n        p0.x += kern;\n        p1.x += kern;\n        this.textWidth += kern;\n        var midpoint = Path.getPointOnLine(kern + width / 2.0, p0.x, p0.y, p1.x, p1.y);\n        var rotation = Math.atan2(p1.y - p0.y, p1.x - p0.x);\n        this.glyphInfo.push({\n          transposeX: midpoint.x,\n          transposeY: midpoint.y,\n          text: charArr[i],\n          rotation: rotation,\n          p0: p0,\n          p1: p1\n        });\n        p0 = p1;\n      }\n    }\n  }, {\n    key: \"getSelfRect\",\n    value: function getSelfRect() {\n      if (!this.glyphInfo.length) {\n        return {\n          x: 0,\n          y: 0,\n          width: 0,\n          height: 0\n        };\n      }\n      var points = [];\n      this.glyphInfo.forEach(function (info) {\n        points.push(info.p0.x);\n        points.push(info.p0.y);\n        points.push(info.p1.x);\n        points.push(info.p1.y);\n      });\n      var minX = points[0] || 0;\n      var maxX = points[0] || 0;\n      var minY = points[1] || 0;\n      var maxY = points[1] || 0;\n      var x, y;\n      for (var i = 0; i < points.length / 2; i++) {\n        x = points[i * 2];\n        y = points[i * 2 + 1];\n        minX = Math.min(minX, x);\n        maxX = Math.max(maxX, x);\n        minY = Math.min(minY, y);\n        maxY = Math.max(maxY, y);\n      }\n      var fontSize = this.fontSize();\n      return {\n        x: minX - fontSize / 2,\n        y: minY - fontSize / 2,\n        width: maxX - minX + fontSize,\n        height: maxY - minY + fontSize\n      };\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      Util.releaseCanvas(this.dummyCanvas);\n      return _get(_getPrototypeOf(TextPath.prototype), \"destroy\", this).call(this);\n    }\n  }]);\n  return TextPath;\n}(Shape);\nTextPath.prototype._fillFunc = _fillFunc;\nTextPath.prototype._strokeFunc = _strokeFunc;\nTextPath.prototype._fillFuncHit = _fillFunc;\nTextPath.prototype._strokeFuncHit = _strokeFunc;\nTextPath.prototype.className = 'TextPath';\nTextPath.prototype._attrsAffectingSize = ['text', 'fontSize', 'data'];\n_registerNode(TextPath);\nFactory.addGetterSetter(TextPath, 'data');\nFactory.addGetterSetter(TextPath, 'fontFamily', 'Arial');\nFactory.addGetterSetter(TextPath, 'fontSize', 12, getNumberValidator());\nFactory.addGetterSetter(TextPath, 'fontStyle', NORMAL);\nFactory.addGetterSetter(TextPath, 'align', 'left');\nFactory.addGetterSetter(TextPath, 'letterSpacing', 0, getNumberValidator());\nFactory.addGetterSetter(TextPath, 'textBaseline', 'middle');\nFactory.addGetterSetter(TextPath, 'fontVariant', NORMAL);\nFactory.addGetterSetter(TextPath, 'text', EMPTY_STRING);\nFactory.addGetterSetter(TextPath, 'textDecoration', null);\nFactory.addGetterSetter(TextPath, 'kerningFunc', null);","map":{"version":3,"names":["Util","Factory","Shape","Path","Text","stringToArray","getNumberValidator","_registerNode","EMPTY_STRING","NORMAL","_fillFunc","context","fillText","partialText","_strokeFunc","strokeText","TextPath","_Shape","_inherits","_super","_createSuper","config","_this","_classCallCheck","call","dummyCanvas","createCanvasElement","dataArray","parsePathData","attrs","data","on","_setTextData","_createClass","key","value","_sceneFunc","setAttr","_getContextFont","textBaseline","save","textDecoration","fill","fontSize","glyphInfo","beginPath","i","length","p0","translate","x","y","rotate","rotation","text","fillStrokeShape","moveTo","lineTo","restore","strokeStyle","lineWidth","stroke","_hitFunc","p1","colorKey","getTextWidth","textWidth","getTextHeight","warn","textHeight","setText","prototype","_getTextSize","_context","getContext","font","metrics","measureText","width","height","parseInt","that","size","letterSpacing","align","kerningFunc","textFullWidth","Math","max","fullPathWidth","l","pathLength","offset","charArr","spacesNumber","split","pathCmd","pIndex","currentT","getNextPathSegment","pathData","j","command","points","findSegmentToFitCharacter","c","glyphWidth","currLen","attempts","undefined","abs","cumulativePathLength","Object","keys","needNewSegment","getLineLength","getPointOnLine","start","dTheta","end","PI","getPointOnEllipticalArc","getPointOnCubicBezier","getPointOnQuadraticBezier","testChar","lettersInOffset","k","kern","e","midpoint","atan2","push","transposeX","transposeY","getSelfRect","forEach","info","minX","maxX","minY","maxY","min","destroy","releaseCanvas","_get","_getPrototypeOf","_fillFuncHit","_strokeFuncHit","className","_attrsAffectingSize","addGetterSetter"],"sources":["/home/DigPatho/Streamlit-Image-Annotation/streamlit_image_annotation/Point/frontend/node_modules/konva/lib/shapes/TextPath.js"],"sourcesContent":["import { Util } from '../Util.js';\nimport { Factory } from '../Factory.js';\nimport { Shape } from '../Shape.js';\nimport { Path } from './Path.js';\nimport { Text, stringToArray } from './Text.js';\nimport { getNumberValidator } from '../Validators.js';\nimport { _registerNode } from '../Global.js';\nvar EMPTY_STRING = '', NORMAL = 'normal';\nfunction _fillFunc(context) {\n    context.fillText(this.partialText, 0, 0);\n}\nfunction _strokeFunc(context) {\n    context.strokeText(this.partialText, 0, 0);\n}\nexport class TextPath extends Shape {\n    constructor(config) {\n        super(config);\n        this.dummyCanvas = Util.createCanvasElement();\n        this.dataArray = [];\n        this.dataArray = Path.parsePathData(this.attrs.data);\n        this.on('dataChange.konva', function () {\n            this.dataArray = Path.parsePathData(this.attrs.data);\n            this._setTextData();\n        });\n        this.on('textChange.konva alignChange.konva letterSpacingChange.konva kerningFuncChange.konva fontSizeChange.konva fontFamilyChange.konva', this._setTextData);\n        this._setTextData();\n    }\n    _sceneFunc(context) {\n        context.setAttr('font', this._getContextFont());\n        context.setAttr('textBaseline', this.textBaseline());\n        context.setAttr('textAlign', 'left');\n        context.save();\n        var textDecoration = this.textDecoration();\n        var fill = this.fill();\n        var fontSize = this.fontSize();\n        var glyphInfo = this.glyphInfo;\n        if (textDecoration === 'underline') {\n            context.beginPath();\n        }\n        for (var i = 0; i < glyphInfo.length; i++) {\n            context.save();\n            var p0 = glyphInfo[i].p0;\n            context.translate(p0.x, p0.y);\n            context.rotate(glyphInfo[i].rotation);\n            this.partialText = glyphInfo[i].text;\n            context.fillStrokeShape(this);\n            if (textDecoration === 'underline') {\n                if (i === 0) {\n                    context.moveTo(0, fontSize / 2 + 1);\n                }\n                context.lineTo(fontSize, fontSize / 2 + 1);\n            }\n            context.restore();\n        }\n        if (textDecoration === 'underline') {\n            context.strokeStyle = fill;\n            context.lineWidth = fontSize / 20;\n            context.stroke();\n        }\n        context.restore();\n    }\n    _hitFunc(context) {\n        context.beginPath();\n        var glyphInfo = this.glyphInfo;\n        if (glyphInfo.length >= 1) {\n            var p0 = glyphInfo[0].p0;\n            context.moveTo(p0.x, p0.y);\n        }\n        for (var i = 0; i < glyphInfo.length; i++) {\n            var p1 = glyphInfo[i].p1;\n            context.lineTo(p1.x, p1.y);\n        }\n        context.setAttr('lineWidth', this.fontSize());\n        context.setAttr('strokeStyle', this.colorKey);\n        context.stroke();\n    }\n    getTextWidth() {\n        return this.textWidth;\n    }\n    getTextHeight() {\n        Util.warn('text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height.');\n        return this.textHeight;\n    }\n    setText(text) {\n        return Text.prototype.setText.call(this, text);\n    }\n    _getContextFont() {\n        return Text.prototype._getContextFont.call(this);\n    }\n    _getTextSize(text) {\n        var dummyCanvas = this.dummyCanvas;\n        var _context = dummyCanvas.getContext('2d');\n        _context.save();\n        _context.font = this._getContextFont();\n        var metrics = _context.measureText(text);\n        _context.restore();\n        return {\n            width: metrics.width,\n            height: parseInt(this.attrs.fontSize, 10),\n        };\n    }\n    _setTextData() {\n        var that = this;\n        var size = this._getTextSize(this.attrs.text);\n        var letterSpacing = this.letterSpacing();\n        var align = this.align();\n        var kerningFunc = this.kerningFunc();\n        this.textWidth = size.width;\n        this.textHeight = size.height;\n        var textFullWidth = Math.max(this.textWidth + ((this.attrs.text || '').length - 1) * letterSpacing, 0);\n        this.glyphInfo = [];\n        var fullPathWidth = 0;\n        for (var l = 0; l < that.dataArray.length; l++) {\n            if (that.dataArray[l].pathLength > 0) {\n                fullPathWidth += that.dataArray[l].pathLength;\n            }\n        }\n        var offset = 0;\n        if (align === 'center') {\n            offset = Math.max(0, fullPathWidth / 2 - textFullWidth / 2);\n        }\n        if (align === 'right') {\n            offset = Math.max(0, fullPathWidth - textFullWidth);\n        }\n        var charArr = stringToArray(this.text());\n        var spacesNumber = this.text().split(' ').length - 1;\n        var p0, p1, pathCmd;\n        var pIndex = -1;\n        var currentT = 0;\n        var getNextPathSegment = function () {\n            currentT = 0;\n            var pathData = that.dataArray;\n            for (var j = pIndex + 1; j < pathData.length; j++) {\n                if (pathData[j].pathLength > 0) {\n                    pIndex = j;\n                    return pathData[j];\n                }\n                else if (pathData[j].command === 'M') {\n                    p0 = {\n                        x: pathData[j].points[0],\n                        y: pathData[j].points[1],\n                    };\n                }\n            }\n            return {};\n        };\n        var findSegmentToFitCharacter = function (c) {\n            var glyphWidth = that._getTextSize(c).width + letterSpacing;\n            if (c === ' ' && align === 'justify') {\n                glyphWidth += (fullPathWidth - textFullWidth) / spacesNumber;\n            }\n            var currLen = 0;\n            var attempts = 0;\n            p1 = undefined;\n            while (Math.abs(glyphWidth - currLen) / glyphWidth > 0.01 &&\n                attempts < 20) {\n                attempts++;\n                var cumulativePathLength = currLen;\n                while (pathCmd === undefined) {\n                    pathCmd = getNextPathSegment();\n                    if (pathCmd &&\n                        cumulativePathLength + pathCmd.pathLength < glyphWidth) {\n                        cumulativePathLength += pathCmd.pathLength;\n                        pathCmd = undefined;\n                    }\n                }\n                if (Object.keys(pathCmd).length === 0 || p0 === undefined) {\n                    return undefined;\n                }\n                var needNewSegment = false;\n                switch (pathCmd.command) {\n                    case 'L':\n                        if (Path.getLineLength(p0.x, p0.y, pathCmd.points[0], pathCmd.points[1]) > glyphWidth) {\n                            p1 = Path.getPointOnLine(glyphWidth, p0.x, p0.y, pathCmd.points[0], pathCmd.points[1], p0.x, p0.y);\n                        }\n                        else {\n                            pathCmd = undefined;\n                        }\n                        break;\n                    case 'A':\n                        var start = pathCmd.points[4];\n                        var dTheta = pathCmd.points[5];\n                        var end = pathCmd.points[4] + dTheta;\n                        if (currentT === 0) {\n                            currentT = start + 0.00000001;\n                        }\n                        else if (glyphWidth > currLen) {\n                            currentT += ((Math.PI / 180.0) * dTheta) / Math.abs(dTheta);\n                        }\n                        else {\n                            currentT -= ((Math.PI / 360.0) * dTheta) / Math.abs(dTheta);\n                        }\n                        if ((dTheta < 0 && currentT < end) ||\n                            (dTheta >= 0 && currentT > end)) {\n                            currentT = end;\n                            needNewSegment = true;\n                        }\n                        p1 = Path.getPointOnEllipticalArc(pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], currentT, pathCmd.points[6]);\n                        break;\n                    case 'C':\n                        if (currentT === 0) {\n                            if (glyphWidth > pathCmd.pathLength) {\n                                currentT = 0.00000001;\n                            }\n                            else {\n                                currentT = glyphWidth / pathCmd.pathLength;\n                            }\n                        }\n                        else if (glyphWidth > currLen) {\n                            currentT += (glyphWidth - currLen) / pathCmd.pathLength / 2;\n                        }\n                        else {\n                            currentT = Math.max(currentT - (currLen - glyphWidth) / pathCmd.pathLength / 2, 0);\n                        }\n                        if (currentT > 1.0) {\n                            currentT = 1.0;\n                            needNewSegment = true;\n                        }\n                        p1 = Path.getPointOnCubicBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], pathCmd.points[4], pathCmd.points[5]);\n                        break;\n                    case 'Q':\n                        if (currentT === 0) {\n                            currentT = glyphWidth / pathCmd.pathLength;\n                        }\n                        else if (glyphWidth > currLen) {\n                            currentT += (glyphWidth - currLen) / pathCmd.pathLength;\n                        }\n                        else {\n                            currentT -= (currLen - glyphWidth) / pathCmd.pathLength;\n                        }\n                        if (currentT > 1.0) {\n                            currentT = 1.0;\n                            needNewSegment = true;\n                        }\n                        p1 = Path.getPointOnQuadraticBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3]);\n                        break;\n                }\n                if (p1 !== undefined) {\n                    currLen = Path.getLineLength(p0.x, p0.y, p1.x, p1.y);\n                }\n                if (needNewSegment) {\n                    needNewSegment = false;\n                    pathCmd = undefined;\n                }\n            }\n        };\n        var testChar = 'C';\n        var glyphWidth = that._getTextSize(testChar).width + letterSpacing;\n        var lettersInOffset = offset / glyphWidth - 1;\n        for (var k = 0; k < lettersInOffset; k++) {\n            findSegmentToFitCharacter(testChar);\n            if (p0 === undefined || p1 === undefined) {\n                break;\n            }\n            p0 = p1;\n        }\n        for (var i = 0; i < charArr.length; i++) {\n            findSegmentToFitCharacter(charArr[i]);\n            if (p0 === undefined || p1 === undefined) {\n                break;\n            }\n            var width = Path.getLineLength(p0.x, p0.y, p1.x, p1.y);\n            var kern = 0;\n            if (kerningFunc) {\n                try {\n                    kern = kerningFunc(charArr[i - 1], charArr[i]) * this.fontSize();\n                }\n                catch (e) {\n                    kern = 0;\n                }\n            }\n            p0.x += kern;\n            p1.x += kern;\n            this.textWidth += kern;\n            var midpoint = Path.getPointOnLine(kern + width / 2.0, p0.x, p0.y, p1.x, p1.y);\n            var rotation = Math.atan2(p1.y - p0.y, p1.x - p0.x);\n            this.glyphInfo.push({\n                transposeX: midpoint.x,\n                transposeY: midpoint.y,\n                text: charArr[i],\n                rotation: rotation,\n                p0: p0,\n                p1: p1,\n            });\n            p0 = p1;\n        }\n    }\n    getSelfRect() {\n        if (!this.glyphInfo.length) {\n            return {\n                x: 0,\n                y: 0,\n                width: 0,\n                height: 0,\n            };\n        }\n        var points = [];\n        this.glyphInfo.forEach(function (info) {\n            points.push(info.p0.x);\n            points.push(info.p0.y);\n            points.push(info.p1.x);\n            points.push(info.p1.y);\n        });\n        var minX = points[0] || 0;\n        var maxX = points[0] || 0;\n        var minY = points[1] || 0;\n        var maxY = points[1] || 0;\n        var x, y;\n        for (var i = 0; i < points.length / 2; i++) {\n            x = points[i * 2];\n            y = points[i * 2 + 1];\n            minX = Math.min(minX, x);\n            maxX = Math.max(maxX, x);\n            minY = Math.min(minY, y);\n            maxY = Math.max(maxY, y);\n        }\n        var fontSize = this.fontSize();\n        return {\n            x: minX - fontSize / 2,\n            y: minY - fontSize / 2,\n            width: maxX - minX + fontSize,\n            height: maxY - minY + fontSize,\n        };\n    }\n    destroy() {\n        Util.releaseCanvas(this.dummyCanvas);\n        return super.destroy();\n    }\n}\nTextPath.prototype._fillFunc = _fillFunc;\nTextPath.prototype._strokeFunc = _strokeFunc;\nTextPath.prototype._fillFuncHit = _fillFunc;\nTextPath.prototype._strokeFuncHit = _strokeFunc;\nTextPath.prototype.className = 'TextPath';\nTextPath.prototype._attrsAffectingSize = ['text', 'fontSize', 'data'];\n_registerNode(TextPath);\nFactory.addGetterSetter(TextPath, 'data');\nFactory.addGetterSetter(TextPath, 'fontFamily', 'Arial');\nFactory.addGetterSetter(TextPath, 'fontSize', 12, getNumberValidator());\nFactory.addGetterSetter(TextPath, 'fontStyle', NORMAL);\nFactory.addGetterSetter(TextPath, 'align', 'left');\nFactory.addGetterSetter(TextPath, 'letterSpacing', 0, getNumberValidator());\nFactory.addGetterSetter(TextPath, 'textBaseline', 'middle');\nFactory.addGetterSetter(TextPath, 'fontVariant', NORMAL);\nFactory.addGetterSetter(TextPath, 'text', EMPTY_STRING);\nFactory.addGetterSetter(TextPath, 'textDecoration', null);\nFactory.addGetterSetter(TextPath, 'kerningFunc', null);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}